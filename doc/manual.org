#+title: ent
#+subtitle: for version {{{package-version}}}
#+author: {{{package-author}}}
#+email: {{{package-email}}}
#+date: 2022-{{{year}}}
#+property: header-args :eval no`
#+options: broken-links:warn \n:nil ::t |:t ^:nil -:t f:t *:t <:t e:t ':t
#+options: d:nil todo:nil pri:nil tags:not-in-toc stat:nil
#+language: en
#+export_file_name: ent.texi
#+texinfo_dir_category: Emacs
#+texinfo_dir_title: ent: (ent)
#+texinfo_dir_desc: Create, distribute, and maintain Emacs Lisp packages
#+macro: package-version (eval (if (require 'erk nil t) (erk-package-version) "0.1.0"))
#+macro: package-author (eval (if (require 'erk nil t) (erk-package-author) "Dan Pomohaci"))
#+macro: package-email (eval (if (require 'erk nil t) (erk-package-email "dan.pomohaci@gmail.com")))
#+macro: year (eval (format-time-string "%Y"))
#+texinfo_header: @comment !!!THIS FILE HAS BEEN GENERATED!!! Edit manual.org instead!

* Welcome

This is a simple org document used to generate an info manual and content for
the README.

* Overview

=ent.el= is a *tiny build‑automation* framework written in pure Emacs‑Lisp.

Its goal is to discover a /project/ (identified by a dedicated
=ent‑project‑config‑filename= file), load the project‑specific build
file, create a set of *tasks* (default and user‑defined) and run a
selected task while reporting the output in a /compilation/ buffer.

* Usage

First of all you need to create a build file ~.ent.el~ in the project root directory.

The minimal form of this file is:
#+begin_src emacs-lisp
;;; .ent.el --- local ent config file -*- lexical-binding: t; -*-

;;; Commentary:

;;; Code:

;; project settings
(setq ent-project-home (file-name-directory (if load-file-name load-file-name buffer-file-name)))
(setq ent-project-name "project name")

(ent-load-default-tasks)

(provide '.ent)
;;; .ent.el ends here

;; Local Variables:
;; no-byte-compile: t
;; no-update-autoloads: t
;; End:
#+end_src

To run a task execute the ~ent-run~ command and select the task from the
list of active tasks. In minimal form only the default tasks are
active (help, clean, dirclean, env) but the big advantage of =ent= is
the ease with which you can create new tasks.

A new task is created with the function:
#+begin_src emacs-lisp
(task "task-name"
      :doc "Explain the functionality of the task."
      :deps "A list of task names on which the task depends separated by space."
      :action "Action to execute")
#+end_src
All the three key parameters (=doc=, =deps= and =action=) are optional but of course a task without any of them makes no sense.

The ~:action~ parameter can be a string or an elisp function. If it is a string then it is a shell command that executes in the root directory of the project. Example:
#+begin_src emacs-lisp
(task "shell-example"
      :doc "List the files in the project root directory after it has been cleaned."
      :deps "clean dirclean"
      :action "ls -la")
#+end_src
The elisp function is a function without any parameters and can be interactive or not. Example:
#+begin_src emacs-lisp
(task "elisp-example"
      :doc "Display a greeting message."
      :action (lambda ()
               (let  ((greeting (completing-read "Greeting: " '("Hello" "Buna" "Bonjour") nil t)))
                 (message "%s Dan" greeting)
                 )))
#+end_src

*Note* To have the functionality of a compilation output buffer set the log file to ~compilation-mode~ after task execution.

* Licensing
:PROPERTIES:
:COPYING: t
:END:

#+include: "../COPYING"

# Local Variables:
# after-save-hook: (lambda () (when (require 'erk nil t) (erk-export-docs)))
# End:
